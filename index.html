<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Video Editor</title>
<style>
  body {
    background: #121417;
    color: #e0e6f1;
    font-family: Arial, sans-serif;
    margin: 0; padding: 20px;
    display: flex; flex-direction: column; align-items: center;
  }
  h1 {
    margin-bottom: 12px;
  }
  #videoContainer {
    background: #222930;
    border-radius: 8px;
    padding: 12px;
    max-width: 700px;
    width: 100%;
  }
  video {
    width: 100%;
    border-radius: 6px;
    background: black;
  }
  .controls {
    margin-top: 12px;
    display: flex; gap: 8px; flex-wrap: wrap;
    justify-content: center;
  }
  button {
    background: #1f7fff;
    border: none;
    padding: 8px 14px;
    border-radius: 6px;
    color: white;
    cursor: pointer;
    font-size: 14px;
  }
  button:disabled {
    background: #6d7a8d;
    cursor: default;
  }
  input[type="file"] {
    display: none;
  }
  label.file-label {
    background: #4a5dff;
    padding: 8px 14px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
  }
  #timeline {
    margin-top: 20px;
    position: relative;
    height: 40px;
    background: #2a3442;
    border-radius: 6px;
    user-select: none;
  }
  #clip {
    position: absolute;
    top: 5px;
    height: 30px;
    background: rgba(31, 120, 255, 0.4);
    border: 2px solid #1f78ff;
    border-radius: 6px;
    cursor: grab;
    display: flex;
    justify-content: space-between;
  }
  .handle {
    width: 12px;
    background: #1f78ff;
    cursor: ew-resize;
    border-radius: 3px;
  }
  #playhead {
    position: absolute;
    top: 0;
    width: 2px;
    height: 40px;
    background: #1f78ff;
  }
  .effects {
    margin-top: 20px;
    display: flex; gap: 12px; align-items: center;
    justify-content: center;
  }
  .effects label {
    font-size: 14px;
  }
  input[type="range"] {
    width: 150px;
  }
  #info {
    margin-top: 16px;
    font-size: 13px;
    color: #9aa4b2;
    text-align: center;
  }
  #dropArea {
    margin-top: 12px;
    border: 2px dashed #3a4661;
    border-radius: 8px;
    padding: 20px;
    text-align: center;
    color: #5c6b8a;
    font-size: 14px;
    cursor: pointer;
  }
  #dropArea.dragover {
    border-color: #1f78ff;
    color: #1f78ff;
  }
</style>
</head>
<body>

<h1>Simple Video Editor</h1>

<div id="videoContainer">
  <video id="video" controls></video>

  <div class="controls">
    <label for="fileInput" class="file-label">Import Video</label>
    <input type="file" id="fileInput" accept="video/*" />
    <button id="playBtn" disabled>Play</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="exportBtn" disabled>Export Trimmed</button>
  </div>

  <div id="timeline">
    <div id="clip">
      <div class="handle" id="leftHandle"></div>
      <div style="flex-grow:1;"></div>
      <div class="handle" id="rightHandle"></div>
    </div>
    <div id="playhead"></div>
  </div>

  <div class="effects">
    <label><input type="checkbox" id="grayscale"> Grayscale</label>
    <label>Brightness
      <input type="range" id="brightness" min="0.3" max="1.7" step="0.01" value="1" />
    </label>
  </div>

  <div id="info">Duration: 0:00</div>

  <div id="dropArea">Or drag & drop a video file here</div>
</div>

<script>
  const video = document.getElementById('video');
  const fileInput = document.getElementById('fileInput');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const exportBtn = document.getElementById('exportBtn');

  const timeline = document.getElementById('timeline');
  const clip = document.getElementById('clip');
  const leftHandle = document.getElementById('leftHandle');
  const rightHandle = document.getElementById('rightHandle');
  const playhead = document.getElementById('playhead');

  const grayscale = document.getElementById('grayscale');
  const brightness = document.getElementById('brightness');
  const info = document.getElementById('info');
  const dropArea = document.getElementById('dropArea');

  let duration = 0;
  let clipStart = 0;
  let clipEnd = 0;

  // Load video file
  function loadVideo(file) {
    const url = URL.createObjectURL(file);
    video.src = url;
    video.load();
    video.onloadedmetadata = () => {
      duration = video.duration;
      clipStart = 0;
      clipEnd = duration;
      updateClipUI();
      info.textContent = `Duration: ${formatTime(duration)}`;
      playBtn.disabled = false;
      pauseBtn.disabled = false;
      exportBtn.disabled = false;
    };
  }

  fileInput.addEventListener('change', e => {
    if (e.target.files.length > 0) {
      loadVideo(e.target.files[0]);
    }
  });

  // Drag and drop support
  dropArea.addEventListener('dragover', e => {
    e.preventDefault();
    dropArea.classList.add('dragover');
  });
  dropArea.addEventListener('dragleave', e => {
    e.preventDefault();
    dropArea.classList.remove('dragover');
  });
  dropArea.addEventListener('drop', e => {
    e.preventDefault();
    dropArea.classList.remove('dragover');
    if (e.dataTransfer.files.length > 0) {
      loadVideo(e.dataTransfer.files[0]);
    }
  });

  // Playback controls
  playBtn.addEventListener('click', () => {
    if (video.currentTime < clipStart || video.currentTime > clipEnd) {
      video.currentTime = clipStart;
    }
    video.play();
  });
  pauseBtn.addEventListener('click', () => video.pause());

  // Pause at clip end
  video.addEventListener('timeupdate', () => {
    if (video.currentTime >= clipEnd) {
      video.pause();
    }
    updatePlayhead();
  });

  // Timeline & Clip UI

  function updateClipUI() {
    const total = duration || 1;
    const trackWidth = timeline.clientWidth;
    const leftPercent = (clipStart / total) * 100;
    const widthPercent = ((clipEnd - clipStart) / total) * 100;

    clip.style.left = leftPercent + '%';
    clip.style.width = widthPercent + '%';
    updatePlayhead();
  }

  function updatePlayhead() {
    const total = duration || 1;
    const trackWidth = timeline.clientWidth;
    const time = Math.min(video.currentTime, duration);
    const leftPx = (time / total) * trackWidth;
    playhead.style.left = leftPx + 'px';
  }

  // Dragging logic for handles
  function makeDraggable(handle, isLeft) {
    let dragging = false;
    let startX = 0;

    handle.addEventListener('mousedown', e => {
      e.preventDefault();
      dragging = true;
      startX = e.clientX;
      document.body.style.userSelect = 'none';
    });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - startX;
      startX = e.clientX;

      const trackRect = timeline.getBoundingClientRect();
      const pxToTime = duration / trackRect.width;

      if (isLeft) {
        clipStart += dx * pxToTime;
        clipStart = Math.min(Math.max(0, clipStart), clipEnd - 0.1);
      } else {
        clipEnd += dx * pxToTime;
        clipEnd = Math.max(clipStart + 0.1, Math.min(duration, clipEnd));
      }
      updateClipUI();
    });
    window.addEventListener('mouseup', () => {
      dragging = false;
      document.body.style.userSelect = '';
    });

    // Touch support
    handle.addEventListener('touchstart', e => {
      dragging = true;
      startX = e.touches[0].clientX;
      document.body.style.userSelect = 'none';
    });
    window.addEventListener('touchmove', e => {
      if (!dragging) return;
      const dx = e.touches[0].clientX - startX;
      startX = e.touches[0].clientX;

      const trackRect = timeline.getBoundingClientRect();
      const pxToTime = duration / trackRect.width;

      if (isLeft) {
        clipStart += dx * pxToTime;
        clipStart = Math.min(Math.max(0, clipStart), clipEnd - 0.1);
      } else {
        clipEnd += dx * pxToTime;
        clipEnd = Math.max(clipStart + 0.1, Math.min(duration, clipEnd));
      }
      updateClipUI();
    });
    window.addEventListener('touchend', () => {
      dragging = false;
      document.body.style.userSelect = '';
    });
  }

  makeDraggable(leftHandle, true);
  makeDraggable(rightHandle, false);

  // Effects

  function applyEffects() {
    let filterStr = '';
    if (grayscale.checked) filterStr += 'grayscale(100%) ';
    filterStr += `brightness(${brightness.value})`;
    video.style.filter = filterStr.trim();
  }
  grayscale.addEventListener('change', applyEffects);
  brightness.addEventListener('input', applyEffects);

  // Export trimmed segment as WebM video

  exportBtn.addEventListener('click', async () => {
    if (!video.src) {
      alert('Import a video first');
      return;
    }
    if (clipEnd - clipStart < 0.2) {
      alert('Selected trim segment is too short');
      return;
    }
    exportBtn.disabled = true;
    exportBtn.textContent = 'Exporting...';

    try {
      // Create offscreen video element to play source without UI interference
      const offscreenVideo = document.createElement('video');
      offscreenVideo.src = video.src;
      offscreenVideo.crossOrigin = 'anonymous';
      offscreenVideo.muted = true;
      await offscreenVideo.play().catch(() => {});
      offscreenVideo.pause();

      offscreenVideo.currentTime = clipStart;

      const width = offscreenVideo.videoWidth || 640;
      const height = offscreenVideo.videoHeight || 360;

      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      function drawFrame() {
        ctx.save();
        let filters = '';
        if (grayscale.checked) filters += 'grayscale(100%) ';
        if (brightness.value !== '1') filters += `brightness(${brightness.value})`;
        ctx.filter = filters.trim();
        ctx.drawImage(offscreenVideo, 0, 0, width, height);
        ctx.restore();
      }

      const stream = canvas.captureStream(30);
      const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      const chunks = [];

      recorder.ondataavailable = e => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };

      recorder.start();

      offscreenVideo.play();

      return new Promise((resolve, reject) => {
        offscreenVideo.addEventListener('timeupdate', () => {
          drawFrame();
          if (offscreenVideo.currentTime >= clipEnd - 0.05) {
            offscreenVideo.pause();
            recorder.stop();
          }
        });

        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'trimmed.webm';
          a.click();
          URL.revokeObjectURL(url);
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export Trimmed';
          resolve();
        };

        recorder.onerror = e => {
          alert('Recording failed or is not supported by your browser.');
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export Trimmed';
          reject(e);
        };
      });
    } catch (err) {
      alert('Error exporting video: ' + err.message);
      exportBtn.disabled = false;
      exportBtn.textContent = 'Export Trimmed';
    }
  });

  // Format seconds into MM:SS
  function formatTime(s) {
    if (!s || isNaN(s)) return '0:00';
    const m = Math.floor(s / 60);
    const sec = Math.floor(s % 60);
    return m + ':' + (sec < 10 ? '0' + sec : sec);
  }

  // Update playhead on window resize
  window.addEventListener('resize', updateClipUI);

</script>

</body>
</html>
